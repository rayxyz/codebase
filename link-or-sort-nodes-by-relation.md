> link nodes
```go
// link process nodes
func linkTheProcessNodeList(nodeList []*pb.ApproveProcessNode) ([]*pb.ApproveProcessNode, error) {
	if nodeList == nil || len(nodeList) == 0 {
		return nil, errors.New("node list is empty")
	}
	if len(nodeList) == 1 {
		nodeList[0].PreId = 0
		nodeList[0].NextId = 0
	} else {
		for i := 0; i < len(nodeList)-1; i++ {
			node := nodeList[i]
			nextNode := nodeList[i+1]
			node.NextId = nextNode.Id
			nextNode.PreId = node.Id
		}
		nodeList[0].PreId = 0
		nodeList[len(nodeList)-1].NextId = 0
	}
	return nodeList, nil
}
```

> sort nodes
```golang
package main

import (
	"fmt"
	"log"
	"strconv"
)

// Node ...
type Node struct {
	ID            int64
	Name          string
	PreID         int64
	NextID        int64
	IsTransferred bool
}

func genNodeList() []*Node {
	var nodeList []*Node
	for i := 0; i < 3; i++ {
		nodeList = append(nodeList, &Node{
			ID:            int64(i + 1),
			Name:          "node_" + strconv.Itoa(i+1),
			PreID:         0,
			NextID:        0,
			IsTransferred: false,
		})
	}

	nodeList[0].NextID = 13
	nodeList[0].IsTransferred = true

	nodeList[1].PreID = 13
	nodeList[1].NextID = 3

	nodeList[2].PreID = 2
	nodeList[2].NextID = 0

	// Special node, it has relastions with node 0 and 1, it is in the middle
	// of both node 0 and 1 in relastions, but not in the storage order.
	nodeList = append(nodeList, &Node{
		ID:            13,
		Name:          "node_13",
		PreID:         1,
		NextID:        2,
		IsTransferred: false,
	})

	return nodeList
}

// Sort node list by relations. Here we use the node list generated by method
// genNodeList, the list has 4 nodes, one of them is different and has id 13.
// We assume we want to sort the list to put the node with ID 13 in the middle
// of nodes with indice 0 and 1. Thus, we can straight the list.
func sortNodeListByRelations(nodeList []*Node) []*Node {
	newNodeList := new([]*Node)
	var firstNode *Node
	for _, v := range nodeList {
		if v.PreID == 0 {
			firstNode = v
		}
	}
	*newNodeList = append(*newNodeList, firstNode)
	findNextNode(firstNode, nodeList, newNodeList)
	return *newNodeList
}

// The method find the next node of the node passed in the arguments, for test reason,
// I don't tune the algorithm, I just blindly find the next node. If the method find the
// next node of the current node, then it will append the next node into the newNodeList.
// Here we should notice that the newNodeList is a pointer of a slice, otherwise, it won't
// store the pointer we put into.
func findNextNode(node *Node, nodeList []*Node, newNodeList *[]*Node) {
	for _, v := range nodeList {
		log.Println("I'm working on it.")
		if node.NextID == v.ID {
			log.Println("I find the next node.")
			*newNodeList = append(*newNodeList, v)
			if v.NextID != 0 {
				findNextNode(v, nodeList, newNodeList)
			}
      			break
		}
	}
}

func main() {
	nodeList := genNodeList()
	sortedNodeList := sortNodeListByRelations(nodeList)
	for _, v := range sortedNodeList {
		fmt.Println("node_id => ", v.ID, "node_name => ", v.Name, " pre_id => ", v.PreID,
			" next_id => ", v.NextID, " is_transferred => ", v.IsTransferred)
	}
}
```
